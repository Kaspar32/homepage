<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #d8d8d8;
        overflow: hidden;
      }
      canvas {
        width: 100vw;
        height: 100vh;
      }
      header {
        color: white;
        width: 100px;
      }

      header {
        background: #d8d8d8;
        padding: 1rem;
        margin-left: 15rem;
        width: max-content;
      }

      header nav {
        display: flex;
        gap: 100px;
      }

      header nav a {
        color: white;
        text-decoration: none;
        font-weight: bold;
      }

      header nav a:hover {
        text-decoration: none;
      }

      .Glas {
        font-size: xx-large;
        font-family: "Copperplate", "Copperplate Gothic Light", sans-serif;

        /* Glassmorphism Core */
        background: rgba(255, 255, 255, 0.1); /* leicht durchsichtiges Weiß */
        border-radius: 15px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);

        /* Effekt und Tiefe */
        box-shadow: 0 8px 32px white;

        /* Optional etwas Padding */
        padding: 10px;
        color: white;
        text-align: center;
      }

      footer {
        position: absolute;
        top: 1300px;
        width: 100vw;
        background-image: url("pattern.jpg");
        background-size: cover; /* skaliert das Bild so, dass es den ganzen Footer bedeckt */
        background-position: center; /* zentriert das Bild */
        color: white; /* damit der Text auf dunklem Bild lesbar bleibt */
        text-align: left; /* Text mittig */
        padding: 20px; /* etwas Abstand zum Rand */
        border-radius: 25px;
      }
    </style>
    <img
      id="pattern"
      src="C:\Users\kaspar.bachmann\Framework\Homepage\V2630_00.jpg"
      alt="Pattern"
      style="display: none"
    />
  </head>

  <body>
    <header>
      <nav>
        <button class="Glas">
          <a href="../homepage/home.html">Home</a>
        </button>

        <button class="Glas">
          <a href="../homepage/videos.html">Vids</a>
        </button>

        <button class="Glas">
          <a href="../homepage/links.html">Links</a>
        </button>
      </nav>
    </header>

    <canvas
      id="c"
      style="
        width: 800px;
        height: 1200px;
        position: absolute;
        top: 85px;
        left: 100px;
        border-radius: 25px;
        border: 4px white;
      "
    ></canvas>
    <script>
      (() => {
        const canvas = document.getElementById("c");
        const ctx = canvas.getContext("2d");

        resize();
        window.addEventListener("resize", resize);

        function resize() {
          canvas.width = innerWidth;
          canvas.height = innerHeight;
        }

        const PARTICLE_COUNT = 500;
        const RADIUS = Math.min(innerWidth, innerHeight) * 0.35;
        const particles = [];

        function initSphere() {
          particles.length = 0;
          const cx = innerWidth / 2;
          const cy = innerHeight / 2;

          for (let i = 0; i < PARTICLE_COUNT; i++) {
            const phi = Math.acos(1 - (2 * (i + 0.5)) / PARTICLE_COUNT);
            const theta = Math.PI * (1 + Math.sqrt(5)) * (i + 0.5);

            const x = Math.cos(theta) * Math.sin(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(phi);

            const homeX = cx + x * RADIUS;
            const homeY = cy + y * RADIUS;

            const vx = (Math.random() - 0.5) * 2;
            const vy = (Math.random() - 0.5) * 2;

            // Blinken: Phase und Geschwindigkeit
            const blinkSpeed = 0.002 + Math.random() * 0.004; // wie schnell
            const blinkOffset = Math.random() * Math.PI * 2; // Startphase

            particles.push({
              x: homeX,
              y: homeY,
              homeX,
              homeY,
              vx,
              vy,
              returning: true,
              blinkSpeed,
              blinkOffset,
            });
          }
        }

        initSphere();

        const EXPLOSION_SPEED = 400;
        const EXPLOSION_DURATION = 800;
        const SPRING = 0.02;
        const DAMPING = 0.88;
        const FRICTION = 0.98;
        let lastExplosion = 0;

        function explode(cx, cy) {
          const now = performance.now();
          lastExplosion = now;

          for (let p of particles) {
            const dx = p.x - cx;
            const dy = p.y - cy;
            const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;

            const nx = dx / dist;
            const ny = dy / dist;

            const speed = EXPLOSION_SPEED * (0.5 + Math.random());
            p.vx = nx * speed * 0.016;
            p.vy = ny * speed * 0.016;
            p.returning = false;
          }

          setTimeout(() => {
            if (lastExplosion === now) {
              for (let p of particles) {
                p.returning = true;
              }
            }
          }, EXPLOSION_DURATION);
        }

        canvas.addEventListener("pointerdown", (e) => {
          explode(e.clientX, e.clientY);
        });

        function animate(time) {
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Butterfly
          let x=400*Math.pow(Math.sin(time*1/1000),2)+150;
          let y=1100;
          ctx.lineWidth = 3;
          ctx.strokeStyle = "white";
          ctx.shadowColor = " white";
          ctx.shadowBlur = "39";
          
          ctx.beginPath();
          ctx.moveTo(120+x, 100+y);
          ctx.bezierCurveTo(320+x, 20+y, 140 + 100*Math.sin(time*1/100)+x, 20+y, 130+x, 40+y);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(120+x, 100+y);
          ctx.bezierCurveTo(-100+x, 20+y, 140+ 100*Math.sin(time*1/100)+x, 20+y, 130+x, 40+y);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(120+x, 100+y);
          ctx.bezierCurveTo(-20+x, 140+y, 120+x, 160+y, 120+x, 100+y);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(120+x, 100+y);
          ctx.bezierCurveTo(250+x, 140+y, 150+x, 160+y, 120+x, 100+y);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(125+x, 90+y, 5, 60, Math.PI / 20, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(135+x, 30+y);
          ctx.lineTo(150+x, 5+y);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(135+x, 30+y);
          ctx.lineTo(125+x, 5+y);
          ctx.stroke();
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.moveTo(120+x, 100+y);
          ctx.bezierCurveTo(300+x, 20+y, 140+ 100*Math.sin(time*1/100)+x, 20+y + 10*Math.sin(time*1/100), 130+x, 40+y);
          ctx.fill();

          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(120+x, 100+y);
          ctx.bezierCurveTo(-80+x, 20+y, 140+ 100*Math.sin(time*1/100)+x, 20+y, 130+x, 40+y);
          ctx.fill();
          ctx.moveTo(120+x, 100+y);
          ctx.bezierCurveTo(-6+x, 140+y, 120+x, 160+y, 120+x, 100+y);
          ctx.fill();

          ctx.beginPath();
          ctx.moveTo(120+x, 100+y);
          ctx.bezierCurveTo(230+x, 140+y, 150+x, 160+y, 120+x, 100+y);
          ctx.fill();





    

          for (let p of particles) {
            if (!p.returning) {
              p.vx *= FRICTION;
              p.vy *= FRICTION;
              p.x += p.vx;
              p.y += p.vy;
            } else {
              const ax = (p.homeX - p.x) * SPRING;
              const ay = (p.homeY - p.y) * SPRING;
              p.vx = (p.vx + ax) * DAMPING;
              p.vy = (p.vy + ay) * DAMPING;
              p.x += p.vx;
              p.y += p.vy;

              if (
                Math.abs(p.x - p.homeX) < 0.5 &&
                Math.abs(p.y - p.homeY) < 0.5 &&
                Math.abs(p.vx) < 0.3 &&
                Math.abs(p.vy) < 0.3
              ) {
                p.x = p.homeX;
                p.y = p.homeY;
                p.vx = (Math.random() - 0.5) * 2;
                p.vy = (Math.random() - 0.5) * 2;
              }
            }

            // Alpha-Wert für Blinken berechnen
            const alpha =
              0.5 + 0.5 * Math.sin(time * p.blinkSpeed + p.blinkOffset);

            ctx.beginPath();
            ctx.fillStyle = `rgba(255,255,255,${alpha})`;
            ctx.shadowColor = " white";
            ctx.shadowBlur = "20";
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
          }

          requestAnimationFrame(animate);
        }

        animate();
      })();
    </script>

    <footer>copyright © 2025</footer>
  </body>
</html>
